[
  {
    "answer_id": "1_1",
    "context_id": "recursion_1",
    "question_id": "1",
    "correct_answer": "Recursion is when a function calls itself to solve a problem. Every recursive function has two parts: the base case, where the recursion stops, and the recursive case, where the function calls itself. Examples factorial calculation, Fibonacci series etc.",
    "correct_score": 2,
    "partially_correct_answer": "Recursion is a way of defining a process calling itself. Every recusrive function has a termination case.",
    "partially_correct_score": 1.5,
    "weak_answer": "Recursion is a process where loop run again and again recursively without terminating.",
    "weak_score": 0
  },
  {
    "answer_id": "1_1_1",
    "context_id": "recursion_1",
    "question_id": "1_1",
    "correct_answer": "In programming, recursion is a technique where a function calls itself to solve a problem. The function works on a smaller version of the original problem each time it calls itself, and the recursion continues until a base case is reached, where the function can return a result without further recursion. Recursive solutions are commonly used in problems like factorial calculation, Fibonacci series, sorting algorithms, searching, tree and graph traversals, and divide and conquer algorithms.",
    "correct_score": 3,
    "partially_correct_answer": "Recurssion is a way of defining a process calling itself. Every recusrive function has a termination case",
    "partially_correct_score": 2,
    "weak_answer": "Recursion is a process where loop run again and again recursively without terminating.",
    "weak_score": 0
  },
  {
    "answer_id": "1_2_1",
    "context_id": "recursion_1",
    "question_id": "1_2",
    "correct_answer": "A function is called recursive when it calls itself to solve a problem. Each recursive call works on a smaller version of the problem, and the process continues until it reaches a base case where the function does not call itself.",
    "correct_score": 2,
    "partially_correct_answer": "A function if it calls itself is called recursive function and stops when it encounters the base condition.",
    "partially_correct_score": 1,
    "weak_answer": "A function is called recursive if its loop never terminates.",
    "weak_score": 0
  },
  {
    "answer_id": "2_1",
    "context_id": "recursion_1",
    "question_id": "2",
    "correct_answer": "The base case in a recursive function is the condition where the function does not call itself and directly returns a value. It ensures that the recursion terminates by providing a stopping point for the sequence of smaller problems.",
    "score": 2,
    "partially_correct_answer": "A base case in a recursive function is that condition where the recursion stops.",
    "partially_correct_score": 1,
    "weak_answer": "A base case is the first condition in the recursive function.",
    "weak_score": 2
  },
  {
    "answer_id": "2_1_1",
    "context_id": "recursion_1",
    "question_id": "2_1",
    "correct_answer": "A base case is important in recursion because it ensures that the recursive function terminates. Without a base case, the sequence of smaller problems would continue indefinitely, causing infinite recursion and potentially a stack overflow.",
    "score": 1,
    "partially_correct_answer": "A base case is necessary a without base case the program will never terminate and run for infinite interval.",
    "partially_correct_score": 0.75,
    "weak_answer": "The base case is necessary for the function to know the condition from where to start.",
    "weak_score": 0
  },
  {
    "answer_id": "2_2_1",
    "context_id": "recursion_1",
    "question_id": "2_2",
    "correct_answer": "If a recursive function doesn’t have a base case, the recursion will continue indefinitely, creating many recursive calls without termination. This can lead to the program running out of memory and result in a stack overflow.",
    "score": 2,
    "partially_correct_answer": "IF a recrusion does not have base case then it would newver have a trremination point.",
    "partially_correct_score": 1,
    "weak_answer": "If the base case is not there it world never start.",
    "weak_score": 0
  },
  {
    "answer_id": "3_1",
    "context_id": "recursion_1",
    "question_id": "3",
    "correct_answer": "void printNumbers(int n) { if (n == 0) return; printf(\"%d \", n); printNumbers(n - 1); }",
    "correct_score": 3,
    "partially_correct_answer": "void print(int n){ if(n==0) return; print(n-1); printf(\"%d\", n); }",
    "partially_correct_score": 1,
    "weak_answer": "void print(int n){ printf(\"%d\", n); while(n>0){ n--; } }",
    "weak_score": 0
  },
  {
    "answer_id": "4_1",
    "context_id": "recursion_1",
    "question_id": "4",
    "correct_answer": "Recursion is a programming technique where a function calls itself directly or indirectly until a base condition is met. Iteration, on the other hand, repeats a set of statements using loops like for or while until a condition becomes false. Recursion uses the call stack for repetition, while iteration uses loop control structures.",
    "correct_score": 3,
    "partially_correct_answer": "Recursion is when a function calls itself, and iteration uses loops to repeat steps.",
    "partially_correct_score": 2,
    "weak_answer": "Recursion and iteration are same methods of repeating code.",
    "weak_score": 0
  },
  {
    "answer_id": "4_1_1",
    "context_id": "recursion_1",
    "question_id": "4_1",
    "correct_answer": "Recursion differs from iteration because recursion involves a function calling itself with a base case to stop, while iteration uses loops that continue until a condition is false. Recursion can mirror the structure of the problem, but adds overhead with each function call.",
    "correct_score": 3,
    "partially_correct_answer": "Recursion is when a function calls itself, while iteration uses loops to repeat actions.",
    "partially_correct_score": 1.5,
    "weak_answer": "Recursion and iteration are same ways of repeating code.",
    "weak_score": 0
  },
  {
    "answer_id": "4_2_1",
    "context_id": "recursion_1",
    "question_id": "4_2",
    "correct_answer": "One advantage of recursion is that it often makes problems easier to solve and code shorter. One disadvantage is that each recursive call uses extra stack memory, which can lead to stack overflow for deep recursion.",
    "correct_score": 3,
    "partially_correct_answer": "Recursion helps make code simpler to write, but it can be slower because of repeated function calls.",
    "partially_correct_score": 1.5,
    "weak_answer": "Recursion is always better than iteration and has no disadvantages.",
    "weak_score": 0
  },
  {
    "answer_id": "5_1",
    "context_id": "recursion_1",
    "question_id": "5",
    "max-marks": 2,
    "correct_answer": "A stack overflow happens when recursive function calls exceed the limit of the call stack due to missing or incorrect base case, leading to the program crash.",
    "correct_score": 2,
    "partially_correct_answer": "Stack overflow happens when there are too many recursive calls and the memory gets full. It happens if recursion does not stop properly.",
    "partially_correct_score": 1.75,
    "weak_answer": "Stack overflow is when the output of the recursive function is too large for the program to handle.",
    "weak_score": 0
  },
  {
    "answer_id": "5_1_1",
    "context_id": "recursion_1",
    "question_id": "5_1",
    "max-marks": 2,
    "correct_answer": "In recursion, stack overflow occurs when the function keeps calling itself without reaching the base case, causing the stack memory to overflow and crash the program.",
    "correct_score": 2,
    "partially_correct_answer": "Stack overflow occurs when a recursive function keeps calling itself too many times and memory gets full.",
    "partially_correct_score": 1.5,
    "weak_answer": "Stack overflow means the recursion result is too big for the computer to print.",
    "weak_score": 0
  },
  {
    "answer_id": "5_2_1",
    "context_id": "recursion_1",
    "question_id": "5_2",
    "max-marks": 3,
    "correct_answer": "Infinite recursion causes a stack overflow because each function call is stored in the call stack. Without a base case, the function keeps calling itself endlessly, filling up the stack until the memory limit is reached.",
    "correct_score": "3",
    "partially_correct_answer": "If recursion never ends, memory keeps increasing and the system can crash.",
    "partially_correct_score": "2",
    "weak_answer": "Infinite recursion happens when the program runs too fast or when the loop is not correct.",
    "weak_score": "0"
  },
  {
    "answer_id": "6_1",
    "context_id": "recursion_1",
    "question_id": "6",
    "correct_answer": "The base case in this recursive function is when n == 0, which returns 1. This stops further recursive calls.",
    "correct_score": "1",
    "partially_correct_answer": "The base case is when n equals 0.",
    "partially_correct_score": "1",
    "weak_answer": "When n is 1, the function stops calling itself.",
    "weak_score": "0"
  },
  {
    "answer_id": "6_2",
    "context_id": "recursion_1",
    "question_id": "6_1",
    "correct_answer": "When factorial(5) is called, the function keeps calling itself with smaller values: factorial(5) → 5 × factorial(4) → 5 × 4 × factorial(3) → 5 × 4 × 3 × factorial(2) → 5 × 4 × 3 × 2 × factorial(1). Finally, factorial(0) returns 1, and all calls return their results back up, giving 120.",
    "correct_score": 2,
    "partially_correct_answer": "It calls itself repeatedly until n becomes 0 and then returns the multiplied result.",
    "partially_correct_score": 1,
    "weak_answer": "It just multiplies numbers until it reaches 5.",
    "weak_score": 0
  },
  {
    "answer_id": "7_1",
    "context_id": "recursion_1",
    "question_id": "7",
    "correct_answer": "int sum(int n) {\n    int result = 0;\n    for (int i = n; i > 0; i--) {\n        result += i;\n    }\n    return result;\n}",
    "correct_score": 5,
    "partially_correct_answer": "The same can be done using a while loop that adds numbers from n down to 1 and returns the sum.",
    "partially_correct_score": 3,
    "weak_answer": "We can use a for loop instead of recursion.",
    "weak_score": 1
  },
  {
    "answer_id": "7_1_1",
    "context_id": "recursion_1",
    "question_id": "7_1",
    "correct_answer": "We can use a for loop to add numbers from n down to 1. For example:\nint sum(int n) {\n    int total = 0;\n    for (int i = n; i >= 1; i--) {\n        total += i;\n    }\n    return total;\n}",
    "correct_score": 5,
    "partially_correct_answer": "Use a loop to repeatedly add numbers until n becomes 0 and return the sum.",
    "partially_correct_score": 3,
    "weak_answer": "we can use a loop instead of recursion to find the result.",
    "weak_score": 1
  },
  {
    "answer_id": "8_1",
    "context_id": "recursion_1",
    "question_id": "8",
    "correct_answer": "Recursive solutions are shorter because they express the logic directly and avoid explicit loops or stack handling.",
    "correct_score": 2,
    "partially_correct_answer": "Recursion is short because it uses function calls instead of loops.",
    "partially_correct_score": 1,
    "weak_answer": "Recursion saves time and makes code faster.",
    "weak_score": 0
  },
  {
    "answer_id": "8_1_1",
    "context_id": "recursion_1",
    "question_id": "8_1",
    "correct_answer": "Programmers prefer recursion when the problem can be divided into smaller similar subproblems, making the logic easier to understand and implement.",
    "correct_score": 2,
    "partially_correct_answer": "Programmers prefer recursion because it is easy to write and understand.",
    "partially_correct_score": 1,
    "weak_answer": "Recursion is better because it is smaller in code size.",
    "weak_score": 0
  },
  {
    "answer_id": "9_1",
    "context_id": "recursion_1",
    "question_id": "9",
    "correct_answer": "Tail recursion is a form of recursion where the recursive call is the last operation in the function, with no additional work after it returns. Because nothing remains to be done after the call, some compilers or runtimes can optimize it to reuse the current stack frame.",
    "correct_score": 4,
    "partially_correct_answer": "Tail recursion is when the function calls itself at the end so that nothing is done after the call.",
    "partially_correct_score": 2,
    "weak_answer": "Tail recursion means the recursion happens at the tail or last line of code.",
    "weak_score": 1
  },
  {
    "answer_id": "9_1_1",
    "context_id": "recursion_1",
    "question_id": "9_1",
    "correct_answer": "Tail recursion is when a function makes a recursive call as its final action (the call is in tail position), allowing possible optimization of the call stack.",
    "correct_score": 2,
    "partially_correct_answer": "A tail recursive function calls itself at the end so it can be optimized.",
    "partially_correct_score": 1,
    "weak_answer": "Tail recursion is recursive call at the end of a function.",
    "weak_score": 0
  },
  {
    "answer_id": "9_2_1",
    "context_id": "recursion_1",
    "question_id": "9_2",
    "correct_answer": "Tail recursion can improve performance because a compiler can perform tail-call optimization, reusing the same stack frame for each call and reducing stack space from O(n) to O(1) in ideal cases.",
    "correct_score": 2,
    "partially_correct_answer": "Tail recursion uses less memory because it can reuse stack frames.",
    "partially_correct_score": 1,
    "weak_answer": "Tail recursion makes recursion faster and uses no stack at all.",
    "weak_score": 0
  },
  {
    "answer_id": "10_1_1",
    "context_id": "recursion_1",
    "question_id": "10",
    "correct_answer": "In-order traversal (recursive) visits the left subtree, then processes the current node, then visits the right subtree. In code:\nvoid inorder(Node* node) {\n  if (node == NULL) return;\n  inorder(node->left);\n  printf(\"%d \", node->data);\n  inorder(node->right);\n}",
    "correct_score": 3,
    "partially_correct_answer": "In-order traversal visits left child, then node, then right child using recursion.",
    "partially_correct_score": 2,
    "weak_answer": "In-order prints nodes in some order using recursion.",
    "weak_score": 1
  },
  {
    "answer_id": "11_1",
    "context_id": "recursion_1",
    "question_id": "11",
    "correct_answer": "Divide and conquer uses recursion to split a problem into smaller subproblems, solve each recursively, and combine the results. For example, Merge Sort splits the array, sorts halves recursively, and then merges them.",
    "correct_score": 3,
    "partially_correct_answer": "Divide and conquer splits problems into parts and solves each using recursion.",
    "partially_correct_score": 2,
    "weak_answer": "Divide and conquer uses recursion to divide the array and then do stuff.",
    "weak_score": 1
  },
  {
    "answer_id": "11_1_1",
    "context_id": "recursion_1",
    "question_id": "11_1",
    "correct_answer": "In Merge Sort, recursion splits the array into halves, sorts them recursively, and merges. In Quick Sort, recursion sorts partitions around a pivot. The recursive calls manage smaller subarrays until base cases.",
    "correct_score": 2,
    "partially_correct_answer": "Merge Sort splits and merges recursively; Quick Sort partitions and recursively sorts parts.",
    "partially_correct_score": 1,
    "weak_answer": "Sorting algorithms use recursion to sort arrays faster.",
    "weak_score": 0
  },
  {
    "answer_id": "11_2_1",
    "context_id": "recursion_1",
    "question_id": "11_2",
    "correct_answer": "Recursion suits divide and conquer problems because the problem naturally reduces to similar smaller subproblems that can be handled by the same function until a base case.",
    "correct_score": 2,
    "partially_correct_answer": "Recursion is good because it breaks problems into smaller parts.",
    "partially_correct_score": 1,
    "weak_answer": "Recursion divides the problem and solves it.",
    "weak_score": 0
  },
  {
    "answer_id": "12_1",
    "context_id": "recursion_1",
    "question_id": "12",
    "correct_answer": "Yes — in theory every recursive algorithm can be converted to an iterative one using an explicit stack or loops. However the iterative version may be more complex and less readable.",
    "correct_score": 2,
    "partially_correct_answer": "You can often rewrite recursion using loops, but it can be harder.",
    "partially_correct_score": 1,
    "weak_answer": "Recursion can be replaced by loops always.",
    "weak_score": 0
  },
  {
    "answer_id": "12_1_1",
    "context_id": "recursion_1",
    "question_id": "12_1",
    "correct_answer": "It is usually possible to replace recursion with iteration, but not always worth it. Converting may increase code complexity and reduce clarity.",
    "correct_score": 2,
    "partially_correct_answer": "Sometimes you can replace recursion but it makes code complex.",
    "partially_correct_score": 1,
    "weak_answer": "You should always convert recursion to iteration.",
    "weak_score": 0
  },
  {
    "answer_id": "12_2_1",
    "context_id": "recursion_1",
    "question_id": "12_2",
    "correct_answer": "Converting recursive solutions to iterative ones may not be worth it because the iterative code can be long, harder to maintain, and less intuitive, even if slightly more efficient.",
    "correct_score": 2,
    "partially_correct_answer": "Iteration might be trickier to write and maintain compared to recursion.",
    "partially_correct_score": 1,
    "weak_answer": "Recursion is always better, so converting is pointless.",
    "weak_score": 0
  },
  {
    "answer_id": "13_1",
    "context_id": "recursion_1",
    "question_id": "13",
    "correct_answer": "This naive recursive Fibonacci has exponential time complexity O(2^n) because it recomputes subproblems, and requires O(n) stack depth (space) due to recursion depth.",
    "correct_score": 3,
    "partially_correct_answer": "The function is exponential in time and uses linear stack depth.",
    "partially_correct_score": 2,
    "weak_answer": "The function is slow and uses memory for calls.",
    "weak_score": 1
  },
  {
    "answer_id": "13_2_1",
    "context_id": "recursion_1",
    "question_id": "13_2",
    "correct_answer": "The recursion requires stack space proportional to the depth of the recursion — O(n) — because each call waits for the next one to finish.",
    "correct_score": 2,
    "partially_correct_answer": "Stack space grows with the recursion depth (about n frames).",
    "partially_correct_score": 1,
    "weak_answer": "It uses stack memory for function calls.",
    "weak_score": 0
  },
  {
    "answer_id": "14_1",
    "context_id": "recursion_1",
    "question_id": "14",
    "correct_answer": "Backtracking is a recursive search technique that explores choices and undoes them if they lead to dead ends. It uses recursion to explore possible solutions (e.g., N-Queens, Sudoku) and backtracks to try alternatives.",
    "correct_score": 4,
    "partially_correct_answer": "Backtracking tries options recursively and goes back when something fails.",
    "partially_correct_score": 2,
    "weak_answer": "Backtracking is using recursion to try many possibilities.",
    "weak_score": 1
  },
  {
    "answer_id": "14_1_1",
    "context_id": "recursion_1",
    "question_id": "14_1",
    "correct_answer": "Backtracking is a technique of trying a choice, recursing to solve the rest, and undoing the choice if it fails. Example: N-Queens places queens row by row and backtracks when a conflict occurs.",
    "correct_score": 3,
    "partially_correct_answer": "Backtracking uses recursion to explore possibilities like in Sudoku or N-Queens.",
    "partially_correct_score": 2,
    "weak_answer": "Backtracking is used to solve puzzles using recursion.",
    "weak_score": 1
  },
  {
    "answer_id": "14_2_1",
    "context_id": "recursion_1",
    "question_id": "14_2",
    "correct_answer": "Recursion helps by exploring states one by one and backtracking when a path fails; in Towers of Hanoi it moves disks recursively, and in Sudoku it fills cells and backtracks on conflict.",
    "correct_score": 2,
    "partially_correct_answer": "Recursion explores options and backtracks, useful in Towers of Hanoi and Sudoku.",
    "partially_correct_score": 1,
    "weak_answer": "Recursion just tries moves until solution found.",
    "weak_score": 0
  },
  {
    "answer_id": "15_1",
    "context_id": "recursion_1",
    "question_id": "15",
    "correct_answer": "Recursion is not always the best choice. It is elegant for some problems, but for deep recursion or performance-critical tasks, iteration or optimized approaches are preferable to avoid stack overflow and overhead.",
    "correct_score": 5,
    "partially_correct_answer": "Recursion is good for some problems but not always best for performance reasons.",
    "partially_correct_score": 3,
    "weak_answer": "Recursion is not always best; sometimes loops are better.",
    "weak_score": 1
  },
  {
    "answer_id": "15_1_1",
    "context_id": "recursion_1",
    "question_id": "15_1",
    "correct_answer": "Example: naive recursive Fibonacci is not best because it recomputes subproblems and is very slow; iterative DP or memoization is better.",
    "correct_score": 2,
    "partially_correct_answer": "Fibonacci is an example where recursion is inefficient without memoization.",
    "partially_correct_score": 1,
    "weak_answer": "Fibonacci recursion is slow and so is not good.",
    "weak_score": 0
  },
  {
    "answer_id": "15_2_1",
    "context_id": "recursion_1",
    "question_id": "15_2",
    "correct_answer": "Factors include problem structure (naturally recursive like trees), performance needs, stack depth, and code readability. Use recursion when it maps well to the problem; prefer iteration for tight performance or limited stack.",
    "correct_score": 2,
    "partially_correct_answer": "Choice depends on readability and performance needs.",
    "partially_correct_score": 1,
    "weak_answer": "It depends on the problem.",
    "weak_score": 0
  },
  {
    "answer_id": "16_1",
    "context_id": "recursion_1",
    "question_id": "16",
    "correct_answer": "The system manages recursive calls using the call stack: each call pushes a stack frame containing parameters and local variables; when the call returns, its frame is popped.",
    "correct_score": 3,
    "partially_correct_answer": "Recursive calls are put on the call stack and removed when finished.",
    "partially_correct_score": 2,
    "weak_answer": "Calls are stored in memory until they finish.",
    "weak_score": 1
  },
  {
    "answer_id": "16_1_1",
    "context_id": "recursion_1",
    "question_id": "16_1",
    "correct_answer": "Function calls are stored as stack frames on the call stack; each frame holds arguments, return address and local variables; frames are popped when functions return.",
    "correct_score": 3,
    "partially_correct_answer": "Each function call gets a frame on the stack that is removed later.",
    "partially_correct_score": 2,
    "weak_answer": "Function calls are saved somewhere in stack memory.",
    "weak_score": 1
  },
  {
    "answer_id": "16_2_1",
    "context_id": "recursion_1",
    "question_id": "16_2",
    "correct_answer": "Local variables for each recursive call are stored in that call's stack frame, so each call has its own copy; when the call returns, its local variables are destroyed.",
    "correct_score": 2,
    "partially_correct_answer": "Each recursive call has separate local variables stored on the stack.",
    "partially_correct_score": 1,
    "weak_answer": "Local variables are shared across recursive calls.",
    "weak_score": 0
  },
  {
    "answer_id": "1_1",
    "context_id": "sorting_1",
    "question_id": "1",
    "correct_answer": "Sorting is an algorithm that arranges elements of a list in a specific order such as ascending or descending, resulting in a reordered permutation of the input.",
    "correct_score": 2,
    "partially_correct_answer": "Sorting means arranging elements in order.",
    "partially_correct_score": 1,
    "weak_answer": "Sorting is storing data.",
    "weak_score": 0
  },
  {
    "answer_id": "2_1",
    "context_id": "sorting_1",
    "question_id": "2",
    "correct_answer": "Sorting is necessary because it reduces problem complexity and improves efficiency in searching and database operations.",
    "correct_score": 2,
    "partially_correct_answer": "Sorting helps in searching faster.",
    "partially_correct_score": 1,
    "weak_answer": "Sorting makes data look neat.",
    "weak_score": 0
  },
  {
    "answer_id": "3_1",
    "context_id": "sorting_1",
    "question_id": "3",
    "correct_answer": "Sorting algorithms are classified based on number of comparisons, number of swaps, memory usage, recursion, stability, and adaptability.",
    "correct_score": 3,
    "partially_correct_answer": "Sorting algorithms are classified using different parameters.",
    "partially_correct_score": 2,
    "weak_answer": "Sorting algorithms are classified by speed.",
    "weak_score": 1
  },
  {
    "answer_id": "3_1_1",
    "context_id": "sorting_1",
    "question_id": "3_1",
    "correct_answer": "Comparison-based sorting algorithms compare elements using key comparisons and generally have best case O(n log n) and worst case O(n²).",
    "correct_score": 3,
    "partially_correct_answer": "Comparison-based sorting compares elements to sort them.",
    "partially_correct_score": 2,
    "weak_answer": "Comparison sorting compares values.",
    "weak_score": 1
  },
  {
    "answer_id": "3_2_1",
    "context_id": "sorting_1",
    "question_id": "3_2",
    "correct_answer": "Linear sorting algorithms such as Counting Sort and Radix Sort do not rely on comparisons and achieve better complexity by restricting input conditions.",
    "correct_score": 3,
    "partially_correct_answer": "Linear sorting algorithms are faster than comparison sorting.",
    "partially_correct_score": 2,
    "weak_answer": "Linear sort uses loops.",
    "weak_score": 1
  },
  {
    "answer_id": "4_1",
    "context_id": "sorting_1",
    "question_id": "4",
    "correct_answer": "In-place sorting algorithms require only O(1) or O(log n) extra memory for temporary storage while sorting the data.",
    "correct_score": 2,
    "partially_correct_answer": "In-place sorting uses very little extra memory.",
    "partially_correct_score": 1,
    "weak_answer": "In-place sorting stores data in files.",
    "weak_score": 0
  },
  {
    "answer_id": "4_1_1",
    "context_id": "sorting_1",
    "question_id": "4_1",
    "correct_answer": "Recursive sorting algorithms use function calls such as Quick Sort, while non-recursive ones include Selection Sort and Insertion Sort.",
    "correct_score": 2,
    "partially_correct_answer": "Some sorting algorithms use recursion.",
    "partially_correct_score": 1,
    "weak_answer": "Recursion means looping.",
    "weak_score": 0
  },
  {
    "answer_id": "5_1",
    "context_id": "sorting_1",
    "question_id": "5",
    "correct_answer": "A sorting algorithm is stable if elements with equal keys maintain their relative order after sorting.",
    "correct_score": 3,
    "partially_correct_answer": "Stable sorting keeps equal elements together.",
    "partially_correct_score": 2,
    "weak_answer": "Stable sorting is fast.",
    "weak_score": 1
  },
  {
    "answer_id": "5_1_1",
    "context_id": "sorting_1",
    "question_id": "5_1",
    "correct_answer": "Adaptive sorting algorithms adjust their performance based on how sorted the input already is, such as Quick Sort.",
    "correct_score": 3,
    "partially_correct_answer": "Adaptive sorting works better for sorted data.",
    "partially_correct_score": 2,
    "weak_answer": "Adaptive sorting adapts itself.",
    "weak_score": 1
  },
  {
    "answer_id": "6_1",
    "context_id": "sorting_1",
    "question_id": "6",
    "correct_answer": "Internal sorting algorithms use only main memory during sorting and assume fast random access to data.",
    "correct_score": 3,
    "partially_correct_answer": "Internal sorting happens in main memory.",
    "partially_correct_score": 2,
    "weak_answer": "Internal sorting is sorting inside CPU.",
    "weak_score": 1
  },
  {
    "answer_id": "6_1",
    "context_id": "sorting_1",
    "question_id": "6_1",
    "correct_answer": "External sorting algorithms use external storage like disk or tape when the data size exceeds main memory capacity.",
    "correct_score": 3,
    "partially_correct_answer": "External sorting is used for large data.",
    "partially_correct_score": 2,
    "weak_answer": "External sorting is sorting outside.",
    "weak_score": 1
  },
  {
    "answer_id": "7_1",
    "context_id": "sorting_1",
    "question_id": "7",
    "correct_answer": "Bubble Sort repeatedly compares adjacent elements and swaps them if they are in the wrong order until no more swaps are needed.",
    "correct_score": 4,
    "partially_correct_answer": "Bubble Sort compares elements and swaps them.",
    "partially_correct_score": 2,
    "weak_answer": "Bubble Sort bubbles numbers.",
    "weak_score": 0
  },
  {
    "answer_id": "7_1_1",
    "context_id": "sorting_1",
    "question_id": "7_1",
    "correct_answer": "Bubble Sort has a time complexity of O(n²) even in the best case, but it can be optimized using a flag to detect already sorted lists.",
    "correct_score": 3,
    "partially_correct_answer": "Bubble Sort is slow but can be optimized.",
    "partially_correct_score": 2,
    "weak_answer": "Bubble Sort is fast.",
    "weak_score": 0
  },
  {
    "answer_id": "8_1",
    "context_id": "sorting_1",
    "question_id": "8",
    "correct_answer": "Based on recursion, sorting algorithms are classified into recursive algorithms like Quick Sort and non-recursive algorithms like Selection Sort, while some algorithms such as Merge Sort use both recursion and iteration.",
    "correct_score": 3,
    "partially_correct_answer": "Sorting algorithms are classified as recursive and non-recursive.",
    "partially_correct_score": 2,
    "weak_answer": "Sorting can be recursive.",
    "weak_score": 1
  },
  {
    "answer_id": "8_1_1",
    "context_id": "sorting_1",
    "question_id": "8_1",
    "correct_answer": "Quick Sort is an example of a recursive sorting algorithm, while Selection Sort and Insertion Sort are examples of non-recursive sorting algorithms.",
    "correct_score": 2,
    "partially_correct_answer": "Quick Sort is recursive and Selection Sort is non-recursive.",
    "partially_correct_score": 1,
    "weak_answer": "Bubble Sort is recursive.",
    "weak_score": 0
  },
  {
    "answer_id": "9_1",
    "context_id": "sorting_1",
    "question_id": "9",
    "correct_answer": "A stable sorting algorithm preserves the relative order of elements with equal keys after sorting.",
    "correct_score": 3,
    "partially_correct_answer": "A stable sorting algorithm keeps equal elements in order.",
    "partially_correct_score": 2,
    "weak_answer": "Stable sorting means sorting correctly.",
    "weak_score": 1
  },
  {
    "answer_id": "9_1_1",
    "context_id": "sorting_1",
    "question_id": "9_1",
    "correct_answer": "If two elements have equal keys, a stable sorting algorithm ensures that their order in the sorted list is the same as in the original list.",
    "correct_score": 3,
    "partially_correct_answer": "Equal elements remain in the same order after sorting.",
    "partially_correct_score": 2,
    "weak_answer": "Stability means elements do not change.",
    "weak_score": 1
  },
  {
    "answer_id": "10_1",
    "context_id": "sorting_1",
    "question_id": "10",
    "correct_answer": "Adaptability refers to how the performance of a sorting algorithm changes based on the pre-sortedness of the input data.",
    "correct_score": 3,
    "partially_correct_answer": "Adaptability depends on input order.",
    "partially_correct_score": 2,
    "weak_answer": "Adaptability means sorting changes.",
    "weak_score": 1
  },
  {
    "answer_id": "11_1",
    "context_id": "sorting_1",
    "question_id": "11",
    "correct_answer": "Internal sorting uses only main memory during sorting, while external sorting uses external storage like disk or tape when data cannot fit into main memory.",
    "correct_score": 4,
    "partially_correct_answer": "Internal sort uses memory and external sort uses disk.",
    "partially_correct_score": 2,
    "weak_answer": "Internal and external sorts are different.",
    "weak_score": 1
  },
  {
    "answer_id": "11_1_1",
    "context_id": "sorting_1",
    "question_id": "11_1",
    "correct_answer": "An internal sorting algorithm sorts data entirely within the main memory.",
    "correct_score": 2,
    "partially_correct_answer": "Internal sorting happens in memory.",
    "partially_correct_score": 1,
    "weak_answer": "Internal sorting is sorting.",
    "weak_score": 0
  },
  {
    "answer_id": "11_2_1",
    "context_id": "sorting_1",
    "question_id": "11_2",
    "correct_answer": "External sorting algorithms are used when data is too large to fit into main memory and require external storage like disks.",
    "correct_score": 2,
    "partially_correct_answer": "External sorting uses disk.",
    "partially_correct_score": 1,
    "weak_answer": "External sorting is outside memory.",
    "weak_score": 0
  },
  {
    "answer_id": "12_1",
    "context_id": "sorting_1",
    "question_id": "12",
    "correct_answer": "External sorting algorithms are required when the dataset is too large to be stored and processed entirely in main memory.",
    "correct_score": 2,
    "partially_correct_answer": "They are needed for large data.",
    "partially_correct_score": 1,
    "weak_answer": "They are faster.",
    "weak_score": 0
  },
  {
    "answer_id": "13_1",
    "context_id": "sorting_1",
    "question_id": "13",
    "correct_answer": "Bubble Sort repeatedly compares adjacent elements and swaps them if they are in the wrong order. This process continues until no more swaps are required.",
    "correct_score": 4,
    "partially_correct_answer": "Bubble Sort compares and swaps elements.",
    "partially_correct_score": 2,
    "weak_answer": "Bubble Sort sorts numbers.",
    "weak_score": 1
  },
  {
    "answer_id": "13_1_1",
    "context_id": "sorting_1",
    "question_id": "13_1",
    "correct_answer": "Bubble Sort is simple because it uses basic comparisons and swaps without complex logic.",
    "correct_score": 2,
    "partially_correct_answer": "It is easy to understand.",
    "partially_correct_score": 1,
    "weak_answer": "It is old.",
    "weak_score": 0
  },
  {
    "answer_id": "13_2_1",
    "context_id": "sorting_1",
    "question_id": "13_2",
    "correct_answer": "Bubble Sort has a time complexity of O(n²) in the average and worst case, and also O(n²) in the best case without optimization.",
    "correct_score": 2,
    "partially_correct_answer": "Bubble Sort has O(n²) time complexity.",
    "partially_correct_score": 1,
    "weak_answer": "Bubble Sort is fast.",
    "weak_score": 0
  },
  {
    "answer_id": "14_1",
    "context_id": "sorting_1",
    "question_id": "14",
    "correct_answer": "Bubble Sort can detect whether the input list is already sorted and terminate early using a flag.",
    "correct_score": 2,
    "partially_correct_answer": "Bubble Sort is easy.",
    "partially_correct_score": 1,
    "weak_answer": "Bubble Sort is best.",
    "weak_score": 0
  },
  {
    "answer_id": "14_1_1",
    "context_id": "sorting_1",
    "question_id": "14_1",
    "correct_answer": "By using a flag to check whether any swaps occur during a pass; if no swaps occur, the list is already sorted.",
    "correct_score": 3,
    "partially_correct_answer": "It checks if swapping happens.",
    "partially_correct_score": 2,
    "weak_answer": "It compares elements.",
    "weak_score": 1
  },
  {
    "answer_id": "15_1",
    "context_id": "sorting_1",
    "question_id": "15",
    "correct_answer": "Bubble Sort is inefficient for large datasets due to its O(n²) time complexity and high number of comparisons.",
    "correct_score": 3,
    "partially_correct_answer": "Bubble Sort is slow for large data.",
    "partially_correct_score": 2,
    "weak_answer": "Bubble Sort is not good.",
    "weak_score": 1
  },
  [
    {
      "answer_id": "16_1",
      "context_id": "sorting_1",
      "question_id": "16",
      "correct_answer": "Selection Sort is a sorting algorithm that repeatedly selects the smallest element from the unsorted part and places it at the beginning.",
      "correct_score": 2,
      "partially_correct_answer": "Selection Sort selects elements one by one.",
      "partially_correct_score": 1,
      "weak_answer": "Selection Sort sorts data.",
      "weak_score": 0
    },
    {
      "answer_id": "16_1_1",
      "context_id": "sorting_1",
      "question_id": "16_1",
      "correct_answer": "Selection Sort works by finding the minimum element in the unsorted portion and swapping it with the first unsorted element in each pass.",
      "correct_score": 3,
      "partially_correct_answer": "Selection Sort finds the smallest element and swaps it.",
      "partially_correct_score": 2,
      "weak_answer": "Selection Sort swaps elements.",
      "weak_score": 1
    },
    {
      "answer_id": "17_1",
      "context_id": "sorting_1",
      "question_id": "17",
      "correct_answer": "Insertion Sort is a sorting algorithm that builds the sorted list one element at a time by inserting elements into their correct position.",
      "correct_score": 2,
      "partially_correct_answer": "Insertion Sort inserts elements in order.",
      "partially_correct_score": 1,
      "weak_answer": "Insertion Sort sorts data.",
      "weak_score": 0
    },
    {
      "answer_id": "17_1_1",
      "context_id": "sorting_1",
      "question_id": "17_1",
      "correct_answer": "Insertion Sort works like sorting playing cards, where each element is placed into its correct position in the already sorted portion.",
      "correct_score": 3,
      "partially_correct_answer": "Insertion Sort places elements correctly.",
      "partially_correct_score": 2,
      "weak_answer": "Insertion Sort moves elements.",
      "weak_score": 1
    },
    {
      "answer_id": "18_1",
      "context_id": "sorting_1",
      "question_id": "18",
      "correct_answer": "Insertion Sort is inspired by sorting playing cards.",
      "correct_score": 1,
      "partially_correct_answer": "Insertion Sort is like card sorting.",
      "partially_correct_score": 1,
      "weak_answer": "Bubble Sort.",
      "weak_score": 0
    },
    {
      "answer_id": "19_1",
      "context_id": "sorting_1",
      "question_id": "19",
      "correct_answer": "Bubble Sort repeatedly swaps adjacent elements, while Selection Sort selects the minimum element and places it at the correct position with fewer swaps.",
      "correct_score": 3,
      "partially_correct_answer": "Bubble Sort swaps often, Selection Sort swaps less.",
      "partially_correct_score": 2,
      "weak_answer": "Both are sorting algorithms.",
      "weak_score": 1
    },
    {
      "answer_id": "19_1_1",
      "context_id": "sorting_1",
      "question_id": "19_1",
      "correct_answer": "Selection Sort makes fewer swaps because it performs only one swap per pass after selecting the minimum element.",
      "correct_score": 2,
      "partially_correct_answer": "Selection Sort swaps less.",
      "partially_correct_score": 1,
      "weak_answer": "Selection Sort is better.",
      "weak_score": 0
    },
    {
      "answer_id": "20_1",
      "context_id": "sorting_1",
      "question_id": "20",
      "correct_answer": "Selection Sort always scans the entire list, whereas Insertion Sort shifts elements and performs better on nearly sorted data.",
      "correct_score": 3,
      "partially_correct_answer": "Insertion Sort is better for sorted data.",
      "partially_correct_score": 2,
      "weak_answer": "Both sort data.",
      "weak_score": 1
    },
    {
      "answer_id": "20_1_1",
      "context_id": "sorting_1",
      "question_id": "20_1",
      "correct_answer": "Insertion Sort performs better when the data is already or nearly sorted.",
      "correct_score": 2,
      "partially_correct_answer": "Insertion Sort works faster sometimes.",
      "partially_correct_score": 1,
      "weak_answer": "Insertion Sort is fast.",
      "weak_score": 0
    },
    {
      "answer_id": "21_1",
      "context_id": "sorting_1",
      "question_id": "21",
      "correct_answer": "The best-case time complexity of Insertion Sort is O(n) when the input is already sorted.",
      "correct_score": 2,
      "partially_correct_answer": "Insertion Sort can be fast for sorted data.",
      "partially_correct_score": 1,
      "weak_answer": "O(n²).",
      "weak_score": 0
    },
    {
      "answer_id": "22_1",
      "context_id": "sorting_1",
      "question_id": "22",
      "correct_answer": "Insertion Sort is adaptive because its performance improves when the input is partially or fully sorted.",
      "correct_score": 3,
      "partially_correct_answer": "Insertion Sort depends on input order.",
      "partially_correct_score": 2,
      "weak_answer": "Insertion Sort changes.",
      "weak_score": 1
    },
    {
      "answer_id": "22_1_1",
      "context_id": "sorting_1",
      "question_id": "22_1",
      "correct_answer": "Selection Sort is not adaptive because it always performs the same number of comparisons regardless of input order.",
      "correct_score": 3,
      "partially_correct_answer": "Selection Sort does not adapt.",
      "partially_correct_score": 2,
      "weak_answer": "Selection Sort is slow.",
      "weak_score": 1
    },
    {
      "answer_id": "23_1",
      "context_id": "sorting_1",
      "question_id": "23",
      "correct_answer": "Insertion Sort is stable, while Selection Sort is not stable because swapping may change the relative order of equal elements.",
      "correct_score": 4,
      "partially_correct_answer": "Insertion Sort is stable.",
      "partially_correct_score": 2,
      "weak_answer": "Both are stable.",
      "weak_score": 0
    },
    {
      "answer_id": "24_1",
      "context_id": "sorting_1",
      "question_id": "24",
      "correct_answer": "Selection Sort has O(n²) time complexity in all cases and O(1) auxiliary space complexity.",
      "correct_score": 4,
      "partially_correct_answer": "Selection Sort is O(n²).",
      "partially_correct_score": 2,
      "weak_answer": "Selection Sort is slow.",
      "weak_score": 1
    },
    {
      "answer_id": "25_1",
      "context_id": "sorting_1",
      "question_id": "25",
      "correct_answer": "Insertion Sort has O(n²) worst-case time complexity, O(n) best-case time complexity, and O(1) auxiliary space complexity.",
      "correct_score": 4,
      "partially_correct_answer": "Insertion Sort is O(n²).",
      "partially_correct_score": 2,
      "weak_answer": "Insertion Sort is fast.",
      "weak_score": 1
    },
    {
      "answer_id": "26_1",
      "context_id": "sorting_1",
      "question_id": "26",
      "correct_answer": "Insertion Sort is preferred for small datasets because it has low overhead and performs efficiently on small or nearly sorted data.",
      "correct_score": 3,
      "partially_correct_answer": "Insertion Sort works well for small data.",
      "partially_correct_score": 2,
      "weak_answer": "Insertion Sort is easy.",
      "weak_score": 1
    },
    {
      "answer_id": "27_1",
      "context_id": "sorting_1",
      "question_id": "27",
      "correct_answer": "Selection Sort is rarely used because it has poor time complexity and does not adapt to input order.",
      "correct_score": 3,
      "partially_correct_answer": "Selection Sort is slow.",
      "partially_correct_score": 2,
      "weak_answer": "Selection Sort is bad.",
      "weak_score": 1
    },
    {
      "answer_id": "28_1",
      "context_id": "sorting_1",
      "question_id": "28",
      "correct_answer": "Selection Sort can be made stable by avoiding direct swaps and instead shifting elements while preserving order.",
      "correct_score": 4,
      "partially_correct_answer": "Selection Sort can be modified to be stable.",
      "partially_correct_score": 2,
      "weak_answer": "Yes, it can be moidified till some extent only.",
      "weak_score": 1
    },
    [
      {
        "answer_id": "I1",
        "context_id": "sorting_1",
        "question_id": "I1",
        "correct_answer": "void bubbleSort(int arr[], int n){ for(int i=0;i<n-1;i++){ for(int j=0;j<n-i-1;j++){ if(arr[j]>arr[j+1]){ int t=arr[j]; arr[j]=arr[j+1]; arr[j+1]=t; } } } }",
        "correct_score": 4,
        "partially_correct_answer": "Bubble sort using two nested loops with swapping.",
        "partially_correct_score": 2,
        "weak_answer": "void bubbleSort(){}",
        "weak_score": 1
      },
      {
        "answer_id": "I1_1",
        "context_id": "sorting_1",
        "question_id": "I1_1",
        "correct_answer": "void bubbleSort(int arr[], int n){ for(int i=0;i<n-1;i++){ for(int j=0;j<n-i-1;j++){ if(arr[j]>arr[j+1]){ int t=arr[j]; arr[j]=arr[j+1]; arr[j+1]=t; } } } }",
        "correct_score": 5,
        "partially_correct_answer": "Bubble Sort code with nested loops.",
        "partially_correct_score": 3,
        "weak_answer": "Bubble sort swaps elements.",
        "weak_score": 1
      },
      {
        "answer_id": "I1_2",
        "context_id": "sorting_1",
        "question_id": "I1_2",
        "correct_answer": "void bubbleSort(int arr[], int n){ int swapped; for(int i=0;i<n-1;i++){ swapped=0; for(int j=0;j<n-i-1;j++){ if(arr[j]>arr[j+1]){ int t=arr[j]; arr[j]=arr[j+1]; arr[j+1]=t; swapped=1; } } if(!swapped) break; } }",
        "correct_score": 5,
        "partially_correct_answer": "Bubble Sort with early stopping flag.",
        "partially_correct_score": 3,
        "weak_answer": "Normal Bubble Sort.",
        "weak_score": 1
      },
      {
        "answer_id": "I1_3",
        "context_id": "sorting_1",
        "question_id": "I1_3",
        "correct_answer": "Time complexity is O(n^2) for average and worst case; optimized version has O(n) best case.",
        "correct_score": 2,
        "partially_correct_answer": "Bubble Sort is O(n^2).",
        "partially_correct_score": 1,
        "weak_answer": "Bubble Sort is slow.",
        "weak_score": 0
      },
      {
        "answer_id": "I2",
        "context_id": "sorting_1",
        "question_id": "I2",
        "correct_answer": "void selectionSort(int arr[], int n){ for(int i=0;i<n-1;i++){ int min=i; for(int j=i+1;j<n;j++) if(arr[j]<arr[min]) min=j; int t=arr[i]; arr[i]=arr[min]; arr[min]=t; } }",
        "correct_score": 4,
        "partially_correct_answer": "Selection sort with minimum selection.",
        "partially_correct_score": 2,
        "weak_answer": "void selectionSort(){}",
        "weak_score": 1
      },
      {
        "answer_id": "I2_1",
        "context_id": "sorting_1",
        "question_id": "I2_1",
        "correct_answer": "void selectionSort(int arr[], int n){ for(int i=0;i<n-1;i++){ int min=i; for(int j=i+1;j<n;j++){ if(arr[j]<arr[min]) min=j; } int t=arr[i]; arr[i]=arr[min]; arr[min]=t; } }",
        "correct_score": 5,
        "partially_correct_answer": "Selection Sort finds minimum and swaps.",
        "partially_correct_score": 3,
        "weak_answer": "Selection Sort swaps elements.",
        "weak_score": 1
      },
      {
        "answer_id": "I2_2",
        "context_id": "sorting_1",
        "question_id": "I2_2",
        "correct_answer": "Worst case number of swaps is (n − 1).",
        "correct_score": 3,
        "partially_correct_answer": "Selection Sort performs limited swaps.",
        "partially_correct_score": 1,
        "weak_answer": "Many swaps.",
        "weak_score": 0
      },
      {
        "answer_id": "I3",
        "context_id": "sorting_1",
        "question_id": "I3",
        "correct_answer": "void insertionSort(int arr[], int n){ for(int i=1;i<n;i++){ int key=arr[i]; int j=i-1; while(j>=0 && arr[j]>key){ arr[j+1]=arr[j]; j--; } arr[j+1]=key; } }",
        "correct_score": 4,
        "partially_correct_answer": "Insertion sort shifts elements.",
        "partially_correct_score": 2,
        "weak_answer": "void insertionSort(){}",
        "weak_score": 1
      },
      {
        "answer_id": "I3_1",
        "context_id": "sorting_1",
        "question_id": "I3_1",
        "correct_answer": "void insertionSort(int arr[], int n){ for(int i=1;i<n;i++){ int key=arr[i]; int j=i-1; while(j>=0 && arr[j]>key){ arr[j+1]=arr[j]; j--; } arr[j+1]=key; } }",
        "correct_score": 5,
        "partially_correct_answer": "Insertion Sort inserts elements in sorted part.",
        "partially_correct_score": 3,
        "weak_answer": "Insertion Sort moves elements.",
        "weak_score": 1
      },
      {
        "answer_id": "I3_2",
        "context_id": "sorting_1",
        "question_id": "I3_2",
        "correct_answer": "int insertionSortCount(int arr[], int n){ int c=0; for(int i=1;i<n;i++){ int key=arr[i]; int j=i-1; while(j>=0 && (++c && arr[j]>key)){ arr[j+1]=arr[j]; j--; } arr[j+1]=key; } return c; }",
        "correct_score": 4,
        "partially_correct_answer": "Insertion Sort with comparison counter.",
        "partially_correct_score": 2,
        "weak_answer": "Insertion Sort only.",
        "weak_score": 1
      },
      {
        "answer_id": "I4",
        "context_id": "sorting_1",
        "question_id": "I4",
        "correct_answer": "If no flag is used to stop early, it is the basic Bubble Sort; presence of a flag indicates optimized version.",
        "correct_score": 3,
        "partially_correct_answer": "Bubble Sort can be basic or optimized.",
        "partially_correct_score": 1,
        "weak_answer": "Bubble Sort.",
        "weak_score": 0
      },
      {
        "answer_id": "I4_1",
        "context_id": "sorting_1",
        "question_id": "I4_1",
        "correct_answer": "void bubbleSort(int arr[], int n){ for(int i=0;i<n-1;i++){ int swapped=0; for(int j=0;j<n-i-1;j++){ if(arr[j]>arr[j+1]){ int t=arr[j]; arr[j]=arr[j+1]; arr[j+1]=t; swapped=1; } } if(!swapped) break; } }",
        "correct_score": 4,
        "partially_correct_answer": "Bubble Sort with flag.",
        "partially_correct_score": 2,
        "weak_answer": "Bubble Sort.",
        "weak_score": 1
      },
      {
        "answer_id": "I5",
        "context_id": "sorting_1",
        "question_id": "I5",
        "correct_answer": "Bubble Sort performs more comparisons in all cases; Insertion Sort reduces comparisons for nearly sorted input.",
        "correct_score": 4,
        "partially_correct_answer": "Insertion Sort uses fewer comparisons.",
        "partially_correct_score": 2,
        "weak_answer": "Both are same.",
        "weak_score": 1
      },
      {
        "answer_id": "I5_1",
        "context_id": "sorting_1",
        "question_id": "I5_1",
        "correct_answer": "Insertion Sort is more suitable for nearly sorted data because the inner while loop runs fewer times.",
        "correct_score": 3,
        "partially_correct_answer": "Insertion Sort works better for sorted data.",
        "partially_correct_score": 2,
        "weak_answer": "Insertion Sort is fast.",
        "weak_score": 1
      },
      {
        "answer_id": "I6",
        "context_id": "sorting_1",
        "question_id": "I6",
        "correct_answer": "void selectionSortPass(int arr[], int n){ for(int i=0;i<n-1;i++){ int min=i; for(int j=i+1;j<n;j++) if(arr[j]<arr[min]) min=j; int t=arr[i]; arr[i]=arr[min]; arr[min]=t; for(int k=0;k<n;k++) printf(\"%d \",arr[k]); printf(\"\\n\"); } }",
        "correct_score": 5,
        "partially_correct_answer": "Selection Sort with display after pass.",
        "partially_correct_score": 3,
        "weak_answer": "Selection Sort.",
        "weak_score": 1
      },
      {
        "answer_id": "I6_1",
        "context_id": "sorting_1",
        "question_id": "I6_1",
        "correct_answer": "void selectionSort(int arr[], int n){ for(int i=0;i<n-1;i++){ int min=i; for(int j=i+1;j<n;j++) if(arr[j]<arr[min]) min=j; if(min!=i){ int t=arr[i]; arr[i]=arr[min]; arr[min]=t; } } }",
        "correct_score": 4,
        "partially_correct_answer": "Selection Sort avoiding unnecessary swaps.",
        "partially_correct_score": 2,
        "weak_answer": "Selection Sort.",
        "weak_score": 1
      }
    ],
    [
      {
        "answer_id": "29_1",
        "context_id": "sorting_3",
        "question_id": "29",
        "correct_answer": "Shell Sort is an improved version of Insertion Sort that allows the exchange of elements far apart using a gap sequence.",
        "correct_score": 2,
        "partially_correct_answer": "Shell Sort is a modified insertion sort.",
        "partially_correct_score": 1,
        "weak_answer": "Shell Sort is a sorting algorithm.",
        "weak_score": 0
      },
      {
        "answer_id": "29_1_1",
        "context_id": "sorting_3",
        "question_id": "29_1",
        "correct_answer": "Shell Sort is called diminishing increment sort because the gap between compared elements is gradually reduced until it becomes 1.",
        "correct_score": 2,
        "partially_correct_answer": "The gap reduces step by step.",
        "partially_correct_score": 1,
        "weak_answer": "Because it decreases.",
        "weak_score": 0
      },
      {
        "answer_id": "30_1",
        "context_id": "sorting_3",
        "question_id": "30",
        "correct_answer": "Merge Sort is a divide-and-conquer sorting algorithm that divides the array into halves, sorts them recursively, and then merges them.",
        "correct_score": 2,
        "partially_correct_answer": "Merge Sort divides and merges arrays.",
        "partially_correct_score": 1,
        "weak_answer": "Merge Sort merges elements.",
        "weak_score": 0
      },
      {
        "answer_id": "30_1_1",
        "context_id": "sorting_3",
        "question_id": "30_1",
        "correct_answer": "Merging is the process of combining two sorted subarrays into a single sorted array.",
        "correct_score": 2,
        "partially_correct_answer": "Merging combines sorted lists.",
        "partially_correct_score": 1,
        "weak_answer": "Merging joins arrays.",
        "weak_score": 0
      },
      {
        "answer_id": "31_1",
        "context_id": "sorting_3",
        "question_id": "31",
        "correct_answer": "Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure to sort elements.",
        "correct_score": 2,
        "partially_correct_answer": "Heap Sort uses heap structure.",
        "partially_correct_score": 1,
        "weak_answer": "Heap Sort sorts data.",
        "weak_score": 0
      },
      {
        "answer_id": "32_1",
        "context_id": "sorting_3",
        "question_id": "32",
        "correct_answer": "Shell Sort improves Insertion Sort by comparing elements far apart using gaps, while Insertion Sort only compares adjacent elements.",
        "correct_score": 3,
        "partially_correct_answer": "Shell Sort is faster than Insertion Sort.",
        "partially_correct_score": 2,
        "weak_answer": "Both sort arrays.",
        "weak_score": 1
      },
      {
        "answer_id": "33_1",
        "context_id": "sorting_3",
        "question_id": "33",
        "correct_answer": "Merge Sort always divides the array and merges sorted halves using extra memory, while Quick Sort partitions the array around a pivot and works in-place.",
        "correct_score": 3,
        "partially_correct_answer": "Merge Sort uses merging and Quick Sort uses partitioning.",
        "partially_correct_score": 2,
        "weak_answer": "Both are divide and conquer algorithms.",
        "weak_score": 1
      },
      {
        "answer_id": "34_1",
        "context_id": "sorting_3",
        "question_id": "34",
        "correct_answer": "In the average case, Quick Sort runs in O(n log n) time because the pivot divides the array into reasonably balanced parts.",
        "correct_score": 3,
        "partially_correct_answer": "Average case is O(n log n).",
        "partially_correct_score": 2,
        "weak_answer": "Quick Sort is fast.",
        "weak_score": 1
      },
      {
        "answer_id": "35_1",
        "context_id": "sorting_3",
        "question_id": "35",
        "correct_answer": "Heap Sort works in-place and is not stable, while Merge Sort is stable but requires additional memory.",
        "correct_score": 3,
        "partially_correct_answer": "Heap Sort uses heap and Merge Sort uses merging.",
        "partially_correct_score": 2,
        "weak_answer": "Both are sorting algorithms.",
        "weak_score": 1
      },
      {
        "answer_id": "36_1",
        "context_id": "sorting_3",
        "question_id": "36",
        "correct_answer": "Choosing a good pivot results in balanced partitions and O(n log n) performance, while a poor pivot leads to unbalanced partitions and O(n²) complexity.",
        "correct_score": 4,
        "partially_correct_answer": "Pivot affects performance of Quick Sort.",
        "partially_correct_score": 2,
        "weak_answer": "Pivot is important.",
        "weak_score": 1
      },
      {
        "answer_id": "36_1_1",
        "context_id": "sorting_3",
        "question_id": "36_1",
        "correct_answer": "Randomized Quick Sort randomly selects a pivot to reduce the chances of worst-case partitioning.",
        "correct_score": 4,
        "partially_correct_answer": "Pivot is chosen randomly.",
        "partially_correct_score": 2,
        "weak_answer": "Quick Sort is random.",
        "weak_score": 1
      },
      {
        "answer_id": "37_1",
        "context_id": "sorting_3",
        "question_id": "37",
        "correct_answer": "Merge Sort has Θ(n log n) time complexity in all cases and Θ(n) auxiliary space complexity.",
        "correct_score": 4,
        "partially_correct_answer": "Merge Sort is O(n log n).",
        "partially_correct_score": 2,
        "weak_answer": "Merge Sort is fast.",
        "weak_score": 1
      },
      {
        "answer_id": "38_1",
        "context_id": "sorting_3",
        "question_id": "38",
        "correct_answer": "Heap Sort has Θ(n log n) time complexity in all cases and uses O(1) auxiliary space.",
        "correct_score": 4,
        "partially_correct_answer": "Heap Sort is O(n log n).",
        "partially_correct_score": 2,
        "weak_answer": "Heap Sort is efficient.",
        "weak_score": 1
      },
      {
        "answer_id": "39_1",
        "context_id": "sorting_3",
        "question_id": "39",
        "correct_answer": "Shell Sort reduces the number of inversions early by allowing distant exchanges, making it faster than other O(n²) algorithms.",
        "correct_score": 3,
        "partially_correct_answer": "Shell Sort is faster due to gaps.",
        "partially_correct_score": 2,
        "weak_answer": "Shell Sort is fast.",
        "weak_score": 1
      }
    ],
    [
      {
        "answer_id": "I7",
        "context_id": "sorting_3",
        "question_id": "I7",
        "correct_answer": "void shellSort(int arr[], int n){ for(int gap=n/2; gap>0; gap/=2){ for(int i=gap;i<n;i++){ int temp=arr[i]; int j=i; while(j>=gap && arr[j-gap]>temp){ arr[j]=arr[j-gap]; j-=gap; } arr[j]=temp; } } }",
        "correct_score": 4,
        "partially_correct_answer": "Shell Sort implementation using gap sequence.",
        "partially_correct_score": 2,
        "weak_answer": "void shellSort(){}",
        "weak_score": 1
      },
      {
        "answer_id": "I7_1",
        "context_id": "sorting_3",
        "question_id": "I7_1",
        "correct_answer": "void shellSort(int arr[], int n){ for(int gap=n/2; gap>0; gap/=2){ for(int i=gap;i<n;i++){ int temp=arr[i]; int j=i; while(j>=gap && arr[j-gap]>temp){ arr[j]=arr[j-gap]; j-=gap; } arr[j]=temp; } } }",
        "correct_score": 5,
        "partially_correct_answer": "Shell Sort code with gap reduction.",
        "partially_correct_score": 3,
        "weak_answer": "Shell Sort with gaps.",
        "weak_score": 1
      },
      {
        "answer_id": "I7_2",
        "context_id": "sorting_3",
        "question_id": "I7_2",
        "correct_answer": "When gap becomes 1, Shell Sort reduces to standard Insertion Sort because elements are compared and shifted one position at a time.",
        "correct_score": 4,
        "partially_correct_answer": "Shell Sort behaves like Insertion Sort for gap 1.",
        "partially_correct_score": 2,
        "weak_answer": "Shell Sort becomes slow.",
        "weak_score": 1
      },
      {
        "answer_id": "I8",
        "context_id": "sorting_3",
        "question_id": "I8",
        "correct_answer": "void mergeSort(int arr[], int l, int r){ if(l<r){ int m=(l+r)/2; mergeSort(arr,l,m); mergeSort(arr,m+1,r); merge(arr,l,m,r); } }",
        "correct_score": 4,
        "partially_correct_answer": "Recursive Merge Sort function.",
        "partially_correct_score": 2,
        "weak_answer": "void mergeSort(){}",
        "weak_score": 1
      },
      {
        "answer_id": "I8_1",
        "context_id": "sorting_3",
        "question_id": "I8_1",
        "correct_answer": "void mergeSort(int arr[], int l, int r){ if(l<r){ int m=(l+r)/2; mergeSort(arr,l,m); mergeSort(arr,m+1,r); merge(arr,l,m,r); } }",
        "correct_score": 5,
        "partially_correct_answer": "Merge Sort using divide and merge.",
        "partially_correct_score": 3,
        "weak_answer": "Merge Sort code.",
        "weak_score": 1
      },
      {
        "answer_id": "I8_2",
        "context_id": "sorting_3",
        "question_id": "I8_2",
        "correct_answer": "void merge(int arr[], int l, int m, int r){ int n1=m-l+1,n2=r-m; int L[n1],R[n2]; for(int i=0;i<n1;i++)L[i]=arr[l+i]; for(int j=0;j<n2;j++)R[j]=arr[m+1+j]; int i=0,j=0,k=l; while(i<n1 && j<n2){ if(L[i]<=R[j]) arr[k++]=L[i++]; else arr[k++]=R[j++]; } while(i<n1) arr[k++]=L[i++]; while(j<n2) arr[k++]=R[j++]; }",
        "correct_score": 4,
        "partially_correct_answer": "Merge function implementation.",
        "partially_correct_score": 2,
        "weak_answer": "Merge two arrays.",
        "weak_score": 1
      },
      {
        "answer_id": "I9",
        "context_id": "sorting_3",
        "question_id": "I9",
        "correct_answer": "void quickSort(int arr[], int low, int high){ if(low<high){ int p=partition(arr,low,high); quickSort(arr,low,p-1); quickSort(arr,p+1,high); } }",
        "correct_score": 4,
        "partially_correct_answer": "Recursive Quick Sort.",
        "partially_correct_score": 2,
        "weak_answer": "void quickSort(){}",
        "weak_score": 1
      },
      {
        "answer_id": "I9_1",
        "context_id": "sorting_3",
        "question_id": "I9_1",
        "correct_answer": "int partition(int arr[], int low, int high){ int pivot=arr[low]; int i=low+1,j=high; while(i<=j){ while(i<=high && arr[i]<=pivot) i++; while(arr[j]>pivot) j--; if(i<j){ int t=arr[i]; arr[i]=arr[j]; arr[j]=t; } } int t=arr[low]; arr[low]=arr[j]; arr[j]=t; return j; }",
        "correct_score": 5,
        "partially_correct_answer": "Quick Sort using first element as pivot.",
        "partially_correct_score": 3,
        "weak_answer": "Quick Sort with pivot.",
        "weak_score": 1
      },
      {
        "answer_id": "I9_2",
        "context_id": "sorting_3",
        "question_id": "I9_2",
        "correct_answer": "int partition(int arr[], int low, int high){ int pivot=arr[high]; int i=low-1; for(int j=low;j<high;j++){ if(arr[j]<=pivot){ i++; int t=arr[i]; arr[i]=arr[j]; arr[j]=t; } } int t=arr[i+1]; arr[i+1]=arr[high]; arr[high]=t; return i+1; }",
        "correct_score": 4,
        "partially_correct_answer": "Partition logic for Quick Sort.",
        "partially_correct_score": 2,
        "weak_answer": "Partition function.",
        "weak_score": 1
      },
      {
        "answer_id": "I10",
        "context_id": "sorting_3",
        "question_id": "I10",
        "correct_answer": "void heapSort(int arr[], int n){ for(int i=n/2-1;i>=0;i--) heapify(arr,n,i); for(int i=n-1;i>0;i--){ int t=arr[0]; arr[0]=arr[i]; arr[i]=t; heapify(arr,i,0); } }",
        "correct_score": 4,
        "partially_correct_answer": "Heap Sort implementation.",
        "partially_correct_score": 2,
        "weak_answer": "void heapSort(){}",
        "weak_score": 1
      },
      {
        "answer_id": "I10_1",
        "context_id": "sorting_3",
        "question_id": "I10_1",
        "correct_answer": "void buildHeap(int arr[], int n){ for(int i=n/2-1;i>=0;i--) heapify(arr,n,i); }",
        "correct_score": 4,
        "partially_correct_answer": "Build max heap.",
        "partially_correct_score": 2,
        "weak_answer": "Heap building.",
        "weak_score": 1
      },
      {
        "answer_id": "I10_2",
        "context_id": "sorting_3",
        "question_id": "I10_2",
        "correct_answer": "void heapify(int arr[], int n, int i){ int largest=i; int l=2*i+1, r=2*i+2; if(l<n && arr[l]>arr[largest]) largest=l; if(r<n && arr[r]>arr[largest]) largest=r; if(largest!=i){ int t=arr[i]; arr[i]=arr[largest]; arr[largest]=t; heapify(arr,n,largest); } }",
        "correct_score": 4,
        "partially_correct_answer": "Heapify function.",
        "partially_correct_score": 2,
        "weak_answer": "Heap function.",
        "weak_score": 1
      }
    ]
  ]
]